//! GUI Font Rendering
//!
//! Bitmap font rendering for the GUI system.

use super::Color;

/// Character dimensions
pub const CHAR_WIDTH: u32 = 6;
pub const CHAR_HEIGHT: u32 = 10;

/// Font glyph data (6x10 bitmap font)
/// Each character is represented as 10 bytes, one per row
pub struct BitmapFont {
    /// Glyph data for ASCII 32-126
    glyphs: [[u8; 10]; 95],
}

impl BitmapFont {
    /// Create the built-in bitmap font
    pub const fn builtin() -> Self {
        let mut glyphs = [[0u8; 10]; 95];

        // Space (32)
        glyphs[0] = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];

        // ! (33)
        glyphs[1] = [0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x08, 0x00, 0x00];

        // " (34)
        glyphs[2] = [0x00, 0x14, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];

        // # (35)
        glyphs[3] = [0x00, 0x14, 0x14, 0x3E, 0x14, 0x3E, 0x14, 0x14, 0x00, 0x00];

        // $ (36)
        glyphs[4] = [0x00, 0x08, 0x1E, 0x28, 0x1C, 0x0A, 0x3C, 0x08, 0x00, 0x00];

        // % (37)
        glyphs[5] = [0x00, 0x30, 0x32, 0x04, 0x08, 0x10, 0x26, 0x06, 0x00, 0x00];

        // & (38)
        glyphs[6] = [0x00, 0x10, 0x28, 0x28, 0x10, 0x2A, 0x24, 0x1A, 0x00, 0x00];

        // ' (39)
        glyphs[7] = [0x00, 0x08, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];

        // ( (40)
        glyphs[8] = [0x00, 0x04, 0x08, 0x10, 0x10, 0x10, 0x08, 0x04, 0x00, 0x00];

        // ) (41)
        glyphs[9] = [0x00, 0x10, 0x08, 0x04, 0x04, 0x04, 0x08, 0x10, 0x00, 0x00];

        // * (42)
        glyphs[10] = [0x00, 0x00, 0x14, 0x08, 0x3E, 0x08, 0x14, 0x00, 0x00, 0x00];

        // + (43)
        glyphs[11] = [0x00, 0x00, 0x08, 0x08, 0x3E, 0x08, 0x08, 0x00, 0x00, 0x00];

        // , (44)
        glyphs[12] = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x08, 0x10, 0x00];

        // - (45)
        glyphs[13] = [0x00, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00];

        // . (46)
        glyphs[14] = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00];

        // / (47)
        glyphs[15] = [0x00, 0x02, 0x02, 0x04, 0x08, 0x10, 0x20, 0x20, 0x00, 0x00];

        // 0 (48)
        glyphs[16] = [0x00, 0x1C, 0x22, 0x26, 0x2A, 0x32, 0x22, 0x1C, 0x00, 0x00];

        // 1 (49)
        glyphs[17] = [0x00, 0x08, 0x18, 0x08, 0x08, 0x08, 0x08, 0x1C, 0x00, 0x00];

        // 2 (50)
        glyphs[18] = [0x00, 0x1C, 0x22, 0x02, 0x0C, 0x10, 0x20, 0x3E, 0x00, 0x00];

        // 3 (51)
        glyphs[19] = [0x00, 0x1C, 0x22, 0x02, 0x0C, 0x02, 0x22, 0x1C, 0x00, 0x00];

        // 4 (52)
        glyphs[20] = [0x00, 0x04, 0x0C, 0x14, 0x24, 0x3E, 0x04, 0x04, 0x00, 0x00];

        // 5 (53)
        glyphs[21] = [0x00, 0x3E, 0x20, 0x3C, 0x02, 0x02, 0x22, 0x1C, 0x00, 0x00];

        // 6 (54)
        glyphs[22] = [0x00, 0x0C, 0x10, 0x20, 0x3C, 0x22, 0x22, 0x1C, 0x00, 0x00];

        // 7 (55)
        glyphs[23] = [0x00, 0x3E, 0x02, 0x04, 0x08, 0x10, 0x10, 0x10, 0x00, 0x00];

        // 8 (56)
        glyphs[24] = [0x00, 0x1C, 0x22, 0x22, 0x1C, 0x22, 0x22, 0x1C, 0x00, 0x00];

        // 9 (57)
        glyphs[25] = [0x00, 0x1C, 0x22, 0x22, 0x1E, 0x02, 0x04, 0x18, 0x00, 0x00];

        // : (58)
        glyphs[26] = [0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00];

        // ; (59)
        glyphs[27] = [0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x08, 0x08, 0x10, 0x00];

        // < (60)
        glyphs[28] = [0x00, 0x02, 0x04, 0x08, 0x10, 0x08, 0x04, 0x02, 0x00, 0x00];

        // = (61)
        glyphs[29] = [0x00, 0x00, 0x00, 0x3E, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x00];

        // > (62)
        glyphs[30] = [0x00, 0x20, 0x10, 0x08, 0x04, 0x08, 0x10, 0x20, 0x00, 0x00];

        // ? (63)
        glyphs[31] = [0x00, 0x1C, 0x22, 0x02, 0x04, 0x08, 0x00, 0x08, 0x00, 0x00];

        // @ (64)
        glyphs[32] = [0x00, 0x1C, 0x22, 0x2E, 0x2A, 0x2E, 0x20, 0x1E, 0x00, 0x00];

        // A (65)
        glyphs[33] = [0x00, 0x08, 0x14, 0x22, 0x22, 0x3E, 0x22, 0x22, 0x00, 0x00];

        // B (66)
        glyphs[34] = [0x00, 0x3C, 0x22, 0x22, 0x3C, 0x22, 0x22, 0x3C, 0x00, 0x00];

        // C (67)
        glyphs[35] = [0x00, 0x1C, 0x22, 0x20, 0x20, 0x20, 0x22, 0x1C, 0x00, 0x00];

        // D (68)
        glyphs[36] = [0x00, 0x38, 0x24, 0x22, 0x22, 0x22, 0x24, 0x38, 0x00, 0x00];

        // E (69)
        glyphs[37] = [0x00, 0x3E, 0x20, 0x20, 0x3C, 0x20, 0x20, 0x3E, 0x00, 0x00];

        // F (70)
        glyphs[38] = [0x00, 0x3E, 0x20, 0x20, 0x3C, 0x20, 0x20, 0x20, 0x00, 0x00];

        // G (71)
        glyphs[39] = [0x00, 0x1C, 0x22, 0x20, 0x2E, 0x22, 0x22, 0x1E, 0x00, 0x00];

        // H (72)
        glyphs[40] = [0x00, 0x22, 0x22, 0x22, 0x3E, 0x22, 0x22, 0x22, 0x00, 0x00];

        // I (73)
        glyphs[41] = [0x00, 0x1C, 0x08, 0x08, 0x08, 0x08, 0x08, 0x1C, 0x00, 0x00];

        // J (74)
        glyphs[42] = [0x00, 0x0E, 0x04, 0x04, 0x04, 0x04, 0x24, 0x18, 0x00, 0x00];

        // K (75)
        glyphs[43] = [0x00, 0x22, 0x24, 0x28, 0x30, 0x28, 0x24, 0x22, 0x00, 0x00];

        // L (76)
        glyphs[44] = [0x00, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3E, 0x00, 0x00];

        // M (77)
        glyphs[45] = [0x00, 0x22, 0x36, 0x2A, 0x2A, 0x22, 0x22, 0x22, 0x00, 0x00];

        // N (78)
        glyphs[46] = [0x00, 0x22, 0x32, 0x2A, 0x26, 0x22, 0x22, 0x22, 0x00, 0x00];

        // O (79)
        glyphs[47] = [0x00, 0x1C, 0x22, 0x22, 0x22, 0x22, 0x22, 0x1C, 0x00, 0x00];

        // P (80)
        glyphs[48] = [0x00, 0x3C, 0x22, 0x22, 0x3C, 0x20, 0x20, 0x20, 0x00, 0x00];

        // Q (81)
        glyphs[49] = [0x00, 0x1C, 0x22, 0x22, 0x22, 0x2A, 0x24, 0x1A, 0x00, 0x00];

        // R (82)
        glyphs[50] = [0x00, 0x3C, 0x22, 0x22, 0x3C, 0x28, 0x24, 0x22, 0x00, 0x00];

        // S (83)
        glyphs[51] = [0x00, 0x1C, 0x22, 0x20, 0x1C, 0x02, 0x22, 0x1C, 0x00, 0x00];

        // T (84)
        glyphs[52] = [0x00, 0x3E, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00];

        // U (85)
        glyphs[53] = [0x00, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x1C, 0x00, 0x00];

        // V (86)
        glyphs[54] = [0x00, 0x22, 0x22, 0x22, 0x22, 0x14, 0x14, 0x08, 0x00, 0x00];

        // W (87)
        glyphs[55] = [0x00, 0x22, 0x22, 0x22, 0x2A, 0x2A, 0x36, 0x22, 0x00, 0x00];

        // X (88)
        glyphs[56] = [0x00, 0x22, 0x22, 0x14, 0x08, 0x14, 0x22, 0x22, 0x00, 0x00];

        // Y (89)
        glyphs[57] = [0x00, 0x22, 0x22, 0x14, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00];

        // Z (90)
        glyphs[58] = [0x00, 0x3E, 0x02, 0x04, 0x08, 0x10, 0x20, 0x3E, 0x00, 0x00];

        // [ (91)
        glyphs[59] = [0x00, 0x1C, 0x10, 0x10, 0x10, 0x10, 0x10, 0x1C, 0x00, 0x00];

        // \ (92)
        glyphs[60] = [0x00, 0x20, 0x20, 0x10, 0x08, 0x04, 0x02, 0x02, 0x00, 0x00];

        // ] (93)
        glyphs[61] = [0x00, 0x1C, 0x04, 0x04, 0x04, 0x04, 0x04, 0x1C, 0x00, 0x00];

        // ^ (94)
        glyphs[62] = [0x00, 0x08, 0x14, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];

        // _ (95)
        glyphs[63] = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00];

        // ` (96)
        glyphs[64] = [0x00, 0x10, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];

        // a (97)
        glyphs[65] = [0x00, 0x00, 0x00, 0x1C, 0x02, 0x1E, 0x22, 0x1E, 0x00, 0x00];

        // b (98)
        glyphs[66] = [0x00, 0x20, 0x20, 0x3C, 0x22, 0x22, 0x22, 0x3C, 0x00, 0x00];

        // c (99)
        glyphs[67] = [0x00, 0x00, 0x00, 0x1C, 0x22, 0x20, 0x22, 0x1C, 0x00, 0x00];

        // d (100)
        glyphs[68] = [0x00, 0x02, 0x02, 0x1E, 0x22, 0x22, 0x22, 0x1E, 0x00, 0x00];

        // e (101)
        glyphs[69] = [0x00, 0x00, 0x00, 0x1C, 0x22, 0x3E, 0x20, 0x1C, 0x00, 0x00];

        // f (102)
        glyphs[70] = [0x00, 0x0C, 0x10, 0x3C, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00];

        // g (103)
        glyphs[71] = [0x00, 0x00, 0x00, 0x1E, 0x22, 0x22, 0x1E, 0x02, 0x1C, 0x00];

        // h (104)
        glyphs[72] = [0x00, 0x20, 0x20, 0x3C, 0x22, 0x22, 0x22, 0x22, 0x00, 0x00];

        // i (105)
        glyphs[73] = [0x00, 0x08, 0x00, 0x18, 0x08, 0x08, 0x08, 0x1C, 0x00, 0x00];

        // j (106)
        glyphs[74] = [0x00, 0x04, 0x00, 0x0C, 0x04, 0x04, 0x04, 0x24, 0x18, 0x00];

        // k (107)
        glyphs[75] = [0x00, 0x20, 0x20, 0x24, 0x28, 0x30, 0x28, 0x24, 0x00, 0x00];

        // l (108)
        glyphs[76] = [0x00, 0x18, 0x08, 0x08, 0x08, 0x08, 0x08, 0x1C, 0x00, 0x00];

        // m (109)
        glyphs[77] = [0x00, 0x00, 0x00, 0x34, 0x2A, 0x2A, 0x2A, 0x22, 0x00, 0x00];

        // n (110)
        glyphs[78] = [0x00, 0x00, 0x00, 0x3C, 0x22, 0x22, 0x22, 0x22, 0x00, 0x00];

        // o (111)
        glyphs[79] = [0x00, 0x00, 0x00, 0x1C, 0x22, 0x22, 0x22, 0x1C, 0x00, 0x00];

        // p (112)
        glyphs[80] = [0x00, 0x00, 0x00, 0x3C, 0x22, 0x22, 0x3C, 0x20, 0x20, 0x00];

        // q (113)
        glyphs[81] = [0x00, 0x00, 0x00, 0x1E, 0x22, 0x22, 0x1E, 0x02, 0x02, 0x00];

        // r (114)
        glyphs[82] = [0x00, 0x00, 0x00, 0x2C, 0x32, 0x20, 0x20, 0x20, 0x00, 0x00];

        // s (115)
        glyphs[83] = [0x00, 0x00, 0x00, 0x1E, 0x20, 0x1C, 0x02, 0x3C, 0x00, 0x00];

        // t (116)
        glyphs[84] = [0x00, 0x10, 0x10, 0x3C, 0x10, 0x10, 0x12, 0x0C, 0x00, 0x00];

        // u (117)
        glyphs[85] = [0x00, 0x00, 0x00, 0x22, 0x22, 0x22, 0x22, 0x1E, 0x00, 0x00];

        // v (118)
        glyphs[86] = [0x00, 0x00, 0x00, 0x22, 0x22, 0x22, 0x14, 0x08, 0x00, 0x00];

        // w (119)
        glyphs[87] = [0x00, 0x00, 0x00, 0x22, 0x2A, 0x2A, 0x2A, 0x14, 0x00, 0x00];

        // x (120)
        glyphs[88] = [0x00, 0x00, 0x00, 0x22, 0x14, 0x08, 0x14, 0x22, 0x00, 0x00];

        // y (121)
        glyphs[89] = [0x00, 0x00, 0x00, 0x22, 0x22, 0x22, 0x1E, 0x02, 0x1C, 0x00];

        // z (122)
        glyphs[90] = [0x00, 0x00, 0x00, 0x3E, 0x04, 0x08, 0x10, 0x3E, 0x00, 0x00];

        // { (123)
        glyphs[91] = [0x00, 0x04, 0x08, 0x08, 0x10, 0x08, 0x08, 0x04, 0x00, 0x00];

        // | (124)
        glyphs[92] = [0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00];

        // } (125)
        glyphs[93] = [0x00, 0x10, 0x08, 0x08, 0x04, 0x08, 0x08, 0x10, 0x00, 0x00];

        // ~ (126)
        glyphs[94] = [0x00, 0x00, 0x00, 0x10, 0x2A, 0x04, 0x00, 0x00, 0x00, 0x00];

        Self { glyphs }
    }

    /// Get glyph data for a character
    pub fn get_glyph(&self, c: char) -> Option<&[u8; 10]> {
        let code = c as u32;
        if code >= 32 && code <= 126 {
            Some(&self.glyphs[(code - 32) as usize])
        } else {
            None
        }
    }

    /// Draw a character to a buffer
    pub fn draw_char(
        &self,
        buffer: &mut [u32],
        screen_width: u32,
        x: i32,
        y: i32,
        c: char,
        color: Color,
    ) {
        if let Some(glyph) = self.get_glyph(c) {
            let argb = color.to_argb();

            for (row, &bits) in glyph.iter().enumerate() {
                for col in 0..CHAR_WIDTH {
                    if (bits >> (5 - col)) & 1 != 0 {
                        let px = x + col as i32;
                        let py = y + row as i32;

                        if px >= 0 && py >= 0 {
                            let idx = (py as u32 * screen_width + px as u32) as usize;
                            if idx < buffer.len() {
                                buffer[idx] = argb;
                            }
                        }
                    }
                }
            }
        }
    }

    /// Draw a string to a buffer
    pub fn draw_string(
        &self,
        buffer: &mut [u32],
        screen_width: u32,
        x: i32,
        y: i32,
        text: &str,
        color: Color,
    ) {
        let mut cx = x;

        for c in text.chars() {
            if c == '\n' {
                // Newline handling would go here
                continue;
            }

            self.draw_char(buffer, screen_width, cx, y, c, color);
            cx += CHAR_WIDTH as i32;
        }
    }

    /// Measure text width
    pub fn measure_width(&self, text: &str) -> u32 {
        text.chars()
            .filter(|&c| c != '\n')
            .count() as u32 * CHAR_WIDTH
    }

    /// Measure text height (single line)
    pub fn measure_height(&self) -> u32 {
        CHAR_HEIGHT
    }
}

/// Global font instance
static FONT: BitmapFont = BitmapFont::builtin();

/// Get the global font
pub fn font() -> &'static BitmapFont {
    &FONT
}

/// Draw text using the global font
pub fn draw_text(
    buffer: &mut [u32],
    screen_width: u32,
    x: i32,
    y: i32,
    text: &str,
    color: Color,
) {
    FONT.draw_string(buffer, screen_width, x, y, text, color);
}

/// Measure text width
pub fn text_width(text: &str) -> u32 {
    FONT.measure_width(text)
}

/// Get character width
pub fn char_width() -> u32 {
    CHAR_WIDTH
}

/// Get character height
pub fn char_height() -> u32 {
    CHAR_HEIGHT
}

/// Text alignment
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum TextAlign {
    Left,
    Center,
    Right,
}

/// Draw aligned text
pub fn draw_text_aligned(
    buffer: &mut [u32],
    screen_width: u32,
    x: i32,
    y: i32,
    width: u32,
    text: &str,
    color: Color,
    align: TextAlign,
) {
    let text_w = text_width(text);

    let draw_x = match align {
        TextAlign::Left => x,
        TextAlign::Center => x + (width as i32 - text_w as i32) / 2,
        TextAlign::Right => x + width as i32 - text_w as i32,
    };

    draw_text(buffer, screen_width, draw_x, y, text, color);
}
